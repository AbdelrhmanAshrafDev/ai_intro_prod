
""" To Install
pip install diffusers transformers torch accelerate
"""

# # Install required packages if not already installed5

## terminal-based gpt-2 v1

# from transformers import pipeline

# print("Loading sentiment analysis pipeline...")
# classifier = pipeline("sentiment-analysis", model="distilbert-base-uncased-finetuned-sst-2-english")
# print("Pipeline loaded.")

# print("Running classifier...")
# result = classifier("I love AI!")
# print("Classification complete.")

# # Print result
# print("Result:", result)


##############################################################

## GUI gpt-2 v1

# from transformers import pipeline

# import tkinter as tk

# def main():
#     root = tk.Tk()
#     root.title("Input Example")

#     # Create an Entry widget
#     entry = tk.Entry(root, width=50)
#     entry.pack(pady=20)

#     # Button to show the input
#     def show_input():
#         print(entry.get())

#     button = tk.Button(root, text="Show Input", command=show_input)
#     button.pack(pady=10)

#     root.mainloop()

# if __name__ == "__main__":
#     main()


# # got = input('Say something for the AI: ')

# print("Loading text generation pipeline...")
# generator = pipeline("text-generation", model="gpt2")
# print("Pipeline loaded.")

# prompt = got # "Once upon a time,"
# print(f"Running generator with prompt: {prompt}")
# result = generator(prompt, max_length=50)  # Generate text with a maximum length of 50 tokens
# print("Generation complete.")

# # Print the text generated by GPT-2
# generated_text = result[0]['generated_text']
# print("Generated Text:", generated_text)


##############################################################

## GUI gpt-2 v2

# from transformers import pipeline
# import tkinter as tk

# def main():
#     # Initialize the text generation pipeline
#     print("Loading text generation pipeline...")
#     generator = pipeline("text-generation", model="gpt2")
#     print("Pipeline loaded.")

#     # Create the main window
#     root = tk.Tk()
#     root.title("AI Text Generator")

#     # Create an Entry widget for user input
#     entry = tk.Entry(root, width=50)
#     entry.pack(pady=20)

#     # Create a Text widget to display generated text
#     output_text = tk.Text(root, wrap=tk.WORD, width=60, height=10)
#     output_text.pack(pady=20)

#     # Function to generate text based on user input
#     def generate_text():
#         # Get user input from the Entry widget
#         prompt = entry.get()
#         if not prompt.strip():  # Check if input is empty
#             output_text.delete(1.0, tk.END)  # Clear output
#             output_text.insert(tk.END, "Please enter a prompt.")  # Show message
#             return
        
#         print(f"Running generator with prompt: {prompt}")
#         result = generator(prompt, max_length=50)  # Generate text with a maximum length of 50 tokens
#         generated_text = result[0]['generated_text']
        
#         # Display the generated text in the Text widget
#         output_text.delete(1.0, tk.END)  # Clear previous output
#         output_text.insert(tk.END, generated_text)  # Insert new generated text

#     # Button to trigger text generation
#     button = tk.Button(root, text="Generate Text", command=generate_text)
#     button.pack(pady=10)

#     root.mainloop()

# if __name__ == "__main__":
#     main()


##############################################################

## GUI gpt-2 v3

# from transformers import pipeline
# import tkinter as tk
# import threading

# def main():
#     # Initialize text generation pipeline
#     print("Loading text generation pipeline...")
#     generator = pipeline("text-generation", model="gpt2")
#     print("Pipeline loaded.")

#     # Create main window
#     root = tk.Tk()
#     root.title("AI Text Generator")

#     # User input entry
#     entry = tk.Entry(root, width=50)
#     entry.pack(pady=20)

#     # Customization: Temperature
#     tk.Label(root, text="Temperature:").pack()
#     temp_entry = tk.Entry(root)
#     temp_entry.insert(0, "0.7")  # Default temperature
#     temp_entry.pack()

#     # Display generated text
#     output_text = tk.Text(root, wrap=tk.WORD, width=60, height=10)
#     output_text.pack(pady=20)

#     # Loading message
#     loading_label = tk.Label(root, text="")
#     loading_label.pack()

#     # Word & character count
#     count_label = tk.Label(root, text="Words: 0 | Characters: 0")
#     count_label.pack()

#     def update_count():
#         text = output_text.get(1.0, tk.END)
#         words = len(text.split())
#         chars = len(text)
#         count_label.config(text=f"Words: {words} | Characters: {chars}")

#     output_text.bind("<KeyRelease>", lambda e: update_count())

#     def generate_text():
#         # Get user input and settings
#         prompt = entry.get()
#         if not prompt.strip():
#             output_text.delete(1.0, tk.END)
#             output_text.insert(tk.END, "Please enter a prompt.")
#             return
#         temperature = float(temp_entry.get())
#         loading_label.config(text="Generating text...")
#         root.update()  # Update UI

#         # Generate text
#         result = generator(prompt, max_length=50, temperature=temperature)
#         generated_text = result[0]['generated_text']

#         # Display generated text
#         output_text.delete(1.0, tk.END)
#         output_text.insert(tk.END, generated_text)
#         loading_label.config(text="")

#     # Asynchronous generation
#     def generate_text_async():
#         threading.Thread(target=generate_text).start()

#     # Generate, clear, and save buttons
#     tk.Button(root, text="Generate Text", command=generate_text_async).pack(pady=10)
#     tk.Button(root, text="Clear Output", command=lambda: output_text.delete(1.0, tk.END)).pack(pady=5)
#     tk.Button(root, text="Save Text", command=lambda: open("generated_text.txt", "w").write(output_text.get(1.0, tk.END))).pack(pady=5)

#     root.mainloop()

# if __name__ == "__main__":
#     main()


##############################################################

## GUI EleutherAI/gpt-neo-125M v1 (stupid)

# from transformers import pipeline
# import tkinter as tk
# from tkinter import filedialog
# import threading

# class AITextGeneratorApp:
#     def __init__(self, root):
#         self.root = root
#         self.root.title("AI Text Generator")

#         # Load text generation model
#         self.generator = self.load_model("EleutherAI/gpt-neo-125M")

#         # Set up UI elements
#         self.create_widgets()

#     def load_model(self, model_name):
#         print(f"Loading {model_name} model...")
#         generator = pipeline("text-generation", model=model_name)
#         print(f"{model_name} loaded successfully.")
#         return generator

#     def create_widgets(self):
#         # User input
#         tk.Label(self.root, text="Enter Prompt:").pack(pady=(10, 0))
#         self.entry = tk.Entry(self.root, width=50)
#         self.entry.pack(pady=(0, 10))

#         # Temperature input
#         tk.Label(self.root, text="Temperature:").pack()
#         self.temp_entry = tk.Entry(self.root, width=10)
#         self.temp_entry.insert(0, "0.7")  # Default temperature
#         self.temp_entry.pack(pady=(0, 10))

#         # Output display
#         self.output_text = tk.Text(self.root, wrap=tk.WORD, width=60, height=10)
#         self.output_text.pack(pady=10)

#         # Loading message
#         self.loading_label = tk.Label(self.root, text="")
#         self.loading_label.pack()

#         # Word and character count
#         self.count_label = tk.Label(self.root, text="Words: 0 | Characters: 0")
#         self.count_label.pack()

#         # Buttons
#         tk.Button(self.root, text="Generate Text", command=self.generate_text_async).pack(pady=5)
#         tk.Button(self.root, text="Clear Output", command=self.clear_output).pack(pady=5)
#         tk.Button(self.root, text="Save Text", command=self.save_text).pack(pady=5)

#         # Event binding
#         self.output_text.bind("<KeyRelease>", self.update_count)

#     def update_count(self, event=None):
#         """Update word and character count for the generated text."""
#         text = self.output_text.get(1.0, tk.END)
#         words = len(text.split())
#         chars = len(text)
#         self.count_label.config(text=f"Words: {words} | Characters: {chars}")

#     def generate_text(self):
#         """Generate text based on the user's input prompt and temperature."""
#         prompt = self.entry.get()
#         if not prompt.strip():
#             self.output_text.delete(1.0, tk.END)
#             self.output_text.insert(tk.END, "Please enter a prompt.")
#             return

#         # Get temperature, with error handling for invalid input
#         try:
#             temperature = float(self.temp_entry.get())
#         except ValueError:
#             self.output_text.insert(tk.END, "\nInvalid temperature value. Please enter a number.")
#             return

#         # Show loading message
#         self.loading_label.config(text="Generating text...")
#         self.root.update()

#         # Generate text
#         result = self.generator(prompt, max_length=100, temperature=temperature)
#         generated_text = result[0]['generated_text']

#         # Display the generated text
#         self.output_text.delete(1.0, tk.END)
#         self.output_text.insert(tk.END, generated_text)
#         self.loading_label.config(text="")  # Clear loading message

#     def generate_text_async(self):
#         """Run text generation asynchronously to keep the UI responsive."""
#         threading.Thread(target=self.generate_text).start()

#     def clear_output(self):
#         """Clear the output text widget."""
#         self.output_text.delete(1.0, tk.END)
#         self.update_count()  # Reset the word and character count

#     def save_text(self):
#         """Save the generated text to a file."""
#         text = self.output_text.get(1.0, tk.END).strip()
#         if not text:
#             self.output_text.insert(tk.END, "\nNo text to save.")
#             return

#         file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
#         if file_path:
#             with open(file_path, "w") as file:
#                 file.write(text)

# # Run the application
# if __name__ == "__main__":
#     root = tk.Tk()
#     app = AITextGeneratorApp(root)
#     root.mainloop()


##############################################################

## GUI gpt-2 v4

# from transformers import pipeline
# import tkinter as tk
# from tkinter import filedialog

# class SimpleTextGenerator:
#     def __init__(self, model_name="gpt2", temperature=0.7):
#         print("Loading model...")
#         self.generator = pipeline("text-generation", model=model_name)
#         self.temperature = temperature
#         print("Model loaded successfully.")

#     def generate(self, prompt, max_length=50):
#         result = self.generator(prompt, max_length=max_length, temperature=self.temperature)
#         return result[0]['generated_text']

# class TextGeneratorApp:
#     def __init__(self, root):
#         self.root = root
#         self.root.title("AI Text Generator")

#         self.model = SimpleTextGenerator("gpt2")  # Switch to a better model if needed

#         self.setup_ui()

#     def setup_ui(self):
#         tk.Label(self.root, text="Prompt:").pack()
#         self.prompt_entry = tk.Entry(self.root, width=50)
#         self.prompt_entry.pack(pady=5)

#         tk.Label(self.root, text="Generated Text:").pack()
#         self.output_text = tk.Text(self.root, wrap=tk.WORD, width=60, height=10)
#         self.output_text.pack(pady=5)

#         tk.Button(self.root, text="Generate Text", command=self.on_generate).pack(pady=5)
#         tk.Button(self.root, text="Clear Text", command=lambda: self.output_text.delete(1.0, tk.END)).pack(pady=5)
#         tk.Button(self.root, text="Save to File", command=self.save_text).pack(pady=5)

#     def on_generate(self):
#         prompt = self.prompt_entry.get().strip()
#         if not prompt:
#             self.output_text.insert(tk.END, "Please enter a prompt.\n")
#             return

#         self.output_text.delete(1.0, tk.END)
#         generated_text = self.model.generate(prompt)
#         self.output_text.insert(tk.END, generated_text)

#     def save_text(self):
#         text = self.output_text.get(1.0, tk.END).strip()
#         if not text:
#             self.output_text.insert(tk.END, "Nothing to save!\n")
#             return

#         file_path = filedialog.asksaveasfilename(defaultextension=".txt")
#         if file_path:
#             with open(file_path, "w") as file:
#                 file.write(text)

# if __name__ == "__main__":
#     root = tk.Tk()
#     app = TextGeneratorApp(root)
#     root.mainloop()


##############################################################

## GUI gpt-2 v5

from transformers import pipeline
import tkinter as tk
from tkinter import filedialog

class GPTextGenerator:
    def __init__(self, model_name="gpt2", temperature=0.7):
        self.model_name = model_name
        self.temperature = temperature
        self.generator = None  # Lazy-load the model for faster app startup

    def load_model(self):
        if not self.generator:
            print("Loading model...")
            self.generator = pipeline("text-generation", model=self.model_name)
            print("Model loaded successfully.")

    def generate(self, prompt, max_tokens=300, max_steps=5):
        self.load_model()
        generated_text = prompt
        for _ in range(max_steps):
            result = self.generator(generated_text[-max_tokens:], 
                                    max_length=max_tokens, 
                                    temperature=self.temperature, 
                                    num_return_sequences=1)
            new_text = result[0]["generated_text"]
            if len(new_text) <= len(generated_text):  # Check for natural stop
                break
            generated_text = new_text
        return generated_text

class TextGeneratorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("AI Text Generator")

        self.model = GPTextGenerator("gpt2")  # Load a more advanced model if desired
        self.setup_ui()

    def setup_ui(self):
        tk.Label(self.root, text="Prompt:").pack()
        self.prompt_entry = tk.Entry(self.root, width=50)
        self.prompt_entry.pack(pady=5)

        tk.Label(self.root, text="Generated Text:").pack()
        self.output_text = tk.Text(self.root, wrap=tk.WORD, width=60, height=10)
        self.output_text.pack(pady=5)

        tk.Button(self.root, text="Generate Text", command=self.on_generate).pack(pady=5)
        tk.Button(self.root, text="Clear Text", command=lambda: self.output_text.delete(1.0, tk.END)).pack(pady=5)
        tk.Button(self.root, text="Save to File", command=self.save_text).pack(pady=5)

    def on_generate(self):
        prompt = self.prompt_entry.get().strip()
        if not prompt:
            self.output_text.insert(tk.END, "Please enter a prompt.\n")
            return

        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, "Generating text...\n")
        self.root.update()

        generated_text = self.model.generate(prompt)
        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, generated_text)

    def save_text(self):
        text = self.output_text.get(1.0, tk.END).strip()
        if not text:
            self.output_text.insert(tk.END, "Nothing to save!\n")
            return

        file_path = filedialog.asksaveasfilename(defaultextension=".txt")
        if file_path:
            with open(file_path, "w") as file:
                file.write(text)

if __name__ == "__main__":
    root = tk.Tk()
    app = TextGeneratorApp(root)
    root.mainloop()
